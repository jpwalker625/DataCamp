---
title: "Data Visualization with GGPLOT2"
author: "Joseph Walker"
date: "September 25, 2017"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

```

#Part 1

Data Visualization combines Statistics and Design to present data in meaningful ways. Good design aids in both the understanding and communication of results. 

**Exploratory Visualizations** are meant to confirm and analyze. They are often data heavy, easy to generate, and intended for a small, specialist audience.

**Explanatory Visualizations** are mean to inform and persuade. They are labor intensive, data specific, and intended for a broader audience such as publications or presentations.

## Scatter Plots

GGPLOT2's functionality relies on the grammar of graphics which has 2 principles: 
* Graphics are distinct layers of grammatical elements 
* Meaningful plots through aesthetic mapping 

The essential grammatical elements are:

* Data - The dataset being plotted
* Aesthetics - The scales onto which we map our data
* Geometries - The visual elements used for our data

Other elements include: 

* Facets 
* Statistics 
* Coordinates 
* Themes 

With GGPLOT2, plots become objects which can be recycled and manipulated by adding on layers and arguments.

Aesthetics vs. Attributes

Aesthetics are Mapped onto the plot using existing data. 

Common aesthetics include: 

* x 
* y 
* color 
* fill 
* size 
* alpha 
* linetype 
* labels 
* shape

These aesthetics can also be used as attributes, but it is important to understand the difference between the two. 
```{r}
#subset/sample the diamonds dataset
diamonds_sample <- sample_n(diamonds, size = 100)

#Create a ggplot object price vs. carat for the Diamonds Dataset
p <- ggplot(data = diamonds_sample, mapping = aes(x = carat, y = price))

#plot the object
p
```

Notice that the ggplot object is plotted, but there is no geometry applied to the object so we don't see any of the data.

Here we will add one of the most common geometries, `geom_point` to the object to get a scatterplot.
```{r}
p + geom_point()

#Here we apply color as an aesthetic.
p + geom_point(aes(color = clarity))

#We can also add the aesthetic to the orignal ggplot object. It is best practice to keep the aesthetics in the same layer as much as possible. This will allow your plotting code to be clearer and more readable.
ggplot(data = diamonds_sample, mapping = aes(x = carat, y = price, color = clarity))+
  geom_point()
```

As noted above, there are a variety of different aesthetics we can apply to our plotting object. Be careful as the more aesthetics you add, the more complex your plot becomes and this is not necessarily a good thing.

```{r}
#plot diamonds_sample using multiple aesthetics
ggplot(diamonds_sample, aes(carat, price, color = clarity, shape = cut, size = color))+
  geom_point()
```

Attributes on the other hand, apply to the entire plot object.

```{r}
p <- ggplot(diamonds_sample, aes(carat, price, color = clarity))

p + geom_point(alpha = 0.6, shape = 18, size = 3)
```

Attributes override Aesthetic layers as shown in the example below.
```{r}
#the color attribute over rides the color = clarity aesthetic
p + geom_point(alpha = 0.6, shape = 18, size = 3, color = "red")
```

### Overplotting

Often is this case that you will have to deal with overplotting:

* Large datasets 
* Imprecise data and so points are not clearly separated on your plot 
* Interval data (i.e. data appears at fixed values) 
* Aligned data values on a single axis. 

As we saw earlier, we can adjust the size, shape, and alpha layers to account for this:
```{r}
p <- ggplot(mtcars, aes(wt, mpg, color = factor(cyl)))

#notice we have some overlapping points. We can do better.
p + geom_point(size = 4)

#adjust the shape and alpha
p + geom_point(size = 4, shape = 1, alpha = 0.6)
```

Another solution to overplotting is the `geom_jitter` function. 

```{r}
p <- ggplot(mtcars, aes(x = cyl, y = wt))

p + geom_point()

# with geom_jitter
p + geom_jitter()
```

As shown above, `geom_jitter` fixed the overplotting, but it overcorrected. We can fix this using a variation on the function, calling the `width` argument.

```{r}
#set the width within the geom_jitter function
p + geom_jitter(width = 0.1)
```

And finally, we can pass the `position_jitter()` function to the `position = ` argument within `geom_point()`

```{r}
p + geom_point(position = position_jitter(0.1))
```

## Histograms & Bar Plots

**Histograms** are useful plots for visualizing distributions of a dataset and ggplot2 comes prepared with the `geom_histgoram` function. 

The default argument is `stat = 'bin'`, separates the continuous variable into bins so you get a sense of the general distribution of the data. The amount of bins defaults to `binwidth = range/30`.

```{r}
#plot histogram of the weight variable from the ChickWeight dataset
p <- ggplot(ChickWeight, aes(weight))
  
p + geom_histogram()

#adjust the binwidth
p + geom_histogram(binwidth = 5)
```

We can also customize the y-axis. By default, the y-axis displays the count of the dataset, but we can change it to display the density. Displaying the density is useful for showing the proprotional frequency of a bin relative to the whole dataset.

```{r}
p + geom_histogram(aes(y = ..density..), binwidth = 5, fill = "steelblue")
```

It could be the case that you want to split your distributions by some factor. To avoid overlap, `geom_histogram` stacks bars at each bin to display the distribution.

```{r}
#plot the chick weight distribution by diet
p <- ggplot(ChickWeight, aes(x = weight, fill = Diet))

p + geom_histogram(binwidth = 5)
```

As you can see, this can be a little difficult to discern. The y-axis count values are a sum of the distribution at that particular bin which can be misleading.  To correct this, we can set `position = "identity"`, which unstacks the bins.

```{r}
p + geom_histogram(binwidth = 5, position = "identity", alpha = 0.6)
```

An even better solution is to use `geom_freqpoly`.

```{r}
#remember to change fill to color 
ggplot(ChickWeight, aes(weight, color = Diet))+
  geom_freqpoly(binwidth = 5)
```

Another common geometry is the `geom_bar` used for bar plots. It has a `position` argument that can take on three arguments:

* stack (the default position)
* fill
* dodge

```{r}
#create barplot with the mtcars dataset
p <- ggplot(mtcars, aes(factor(cyl), fill = factor(am)))

#bar plot with default position = "stack"
p+geom_bar()

#position fill
p + geom_bar(position = "fill")

#position dodge
p + geom_bar(position = 'dodge')

#overlapping bars
p + geom_bar(position = position_dodge(width = 0.3), alpha = 0.6)
```