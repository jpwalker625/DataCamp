---
title: "Iteration with Purrr"
author: "Joseph Walker"
date: "December 13, 2018"
output: html_document
---

```{r include = FALSE}
knitr::opts_chunk$set(warning = F, message = F)
```


# Introduction to Purrr

```{r}
library(tidyverse)
library(repurrrsive)

#load the dataset
data("sw_species")

#examine the first element in sw_species
glimpse(sw_species[[2]])

```

As shown above, we can use double brackets to subset an item or element in a list. In the case of the `sw_species` list, the second element corresponds to another list composed of information for Yoda's species.

Another way to subset a list is by name using the `$` followed by the `listelementname` but the `sw_species` does not have names so we can't do this yet.

```{r}
#Get the names of the list elements
names(sw_species)
```

Our first task then will be to apply names to each element using the `$name` subelement from each species sublist. One way to do this is by going through each list individually as so:

```{r}
#get the name element from the first list in sw_species
(names(sw_species)[[1]] <- sw_species[[1]]$name)

#examines the names of the sw_species once again
names(sw_species)
```

This is painstakingly tedious and inefficent. One could use a for loop to do this, but there's an even better way.

We can use the `set_names` function in conjunction with `map` to set the names of each list using the `$name` subelement.

```{r}
#name the list of sw_species using the names subelement
sw_species <- sw_species %>%
  set_names(map(sw_species, "name"))
  
#examine the names of sw_species
names(sw_species)

#subset one of the lists using the $listelementname
sw_species$Ewok
```

By default, the map function returns elements in the form of a list. However,  there are variants which will return the elements based on the type of class as specified in the name.

Here are the various map *flavors* for rererence:

map_* | output
----- | ------
map_chr() | character vector
map_lgl() | logical vector [T or F]
map_int() | integer vector
map_dbl() | double vector (numeric)
map_df()  | as data frame

As an example, let's use the `map_chr` function to grab the `$language` element from each species list which will return a character vector of the languages. Then we will use this character vector to create a data frame linking the languages back to the names of each species.

In order to do so we need to clarify a few things first:

**To specify how the list is used in the function, use the argument .x to denote where the list element goes inside the function. When you want to use .x to show where the element goes in the function, you need to put a ~ in front of the function in the second argument of map().**

```{r}
data.frame(culture = map_chr(sw_species, ~.x$language)) %>%
  rownames_to_column(var = "character") %>%
  head(10)
```

# More Complex Operations

## Piping

In the examples above, we saw that it is possible to using piping with the map function. The pipe allows us to streamline our code and makes it more human readable. Here's another example: 

```{r}
#create a numeric list
(numlist <- list(c(1:10), c(11:20), c(21:30)))

#use pipes to perform multiple operations
numlist %>%
  map(~.x %>% 
      sum %>% 
      sqrt %>% 
      sin)
```

Simple mathematical operations are just the tip of the iceberg to what is possible. In this example, we'll create some simulated data for housing around the bay area.

```{r}
#create a list of areas
area <- list("San Francisco", "Oakland", "San Jose")

#create a list of dataframes with simulated data for each tree species
list_of_df <- map(area,
                  ~data.frame(area = .x,
                              price = rnorm(mean = 800000,
                                            n = 100,
                                            sd = 800000/2.5),
                              sq_ft = rnorm(mean = 1200,
                                             n = 100,
                                             sd = 1200/4)
                  )
)

#examine a portion of the simulated data
map(.x = list_of_df, .f = ~.x %>% head)
```

Now that we have the data let's model each area using the map function.

```{r}
#model the data using pipes and the map function
#notice that model function AND the summary function fall within the .f argument of the map function
list_of_df %>%
  map(.f = ~.x %>% lm(price ~ sq_ft, data = .) %>% summary)
```

## multiple lists/datasets

`Purrr` makes it easy to perform function(s) over multiple lists or datasets. For two lists, we can use `map2` which requuires `.x` and `.y`  as your list arguments. `pmap` handles more than two lists.

First let's create a few lists
```{r}
#create a list of names
names_list <-map(sw_species, .f = ~.$name)

#create a list of lifespans
lifespan_list <- map(sw_species, .f = ~.$average_lifespan)

#create a list of languages
language_list <- map(sw_species, .f = ~.$language)
```

Now let's create a dataframe using two of the lists
```{r}
#create a dataframe with the names and lifespan lists
map2_df(.x = names_list, .y = lifespan_list, .f = ~data.frame(names = .x, avg_lifespan = .y))
```

`pmap` works a little differently. First, we need to create a master list, a list of lists so-to-speak.

```{r}
#create a master list
species_info_list <- list(names = names_list, avg_lifespan = lifespan_list, language = language_list)

pmap_df(.l = species_info_list, .f = function(names, avg_lifespan, language) data.frame(names = names, avg_lifespan = avg_lifespan, language = language))
```

Here's another example where we don't need to use the function argument to define the list elements

```{r}
a <- list(1:100)
b <- list(rnorm(10, 25, 2))
c <- list(seq(from = 10, to = 1000, by = 3))

pmap(.l = list(a,b,c), .f = sum)
```

# Troubleshooting Lists

### Safely
`safely` runs through a list returning result and error components allowing one to pinpoint the issue(s). 

```{r error=T}
#create a list 'foo'
foo <- list(3, -10, Inf, "a")

#use map function on foo
map(foo, log)
```

As you see, we get an error somewhere in the list. We know that we can't take the log of "a", but what if our list was much larger? It would be very difficult to troubleshoot. This is exactly what `safely` is designed for.

```{r}
#use safely with map function
map(foo, .f = safely(log, otherwise = NA_real_))

```

It is useful to use the `transpose` function in conjunction with troubleshooting functions such as safely to convert a list of pairs into a pair of lists for easier comprehension.

```{r}
#use transpose after function to split out results and errors
foo %>%
  map(safely(log, otherwise = NA_real_)) %>% 
  transpose()
```

### Possibly

Once we have figured out where the errors exist, we can replace `safely` with `possibly` to implement the change (e.g. inserting an 'NA' where all errors occur) without returning the error message.

```{r}
#use possibly to output list without errors
foo %>%
  map_dbl(possibly(log, otherwise = NA_real_))
```

Let's take a look at one more example using the Star Wars Species data we're already familiar with. Within the species list, there is a height subelement indicating the height of each species in cm. Let's isolate this element and convert it to feet.

```{r}
#extract the height subelement
sw_species %>%
  map(~.$average_height) %>%
  map_dbl(as.numeric) %>%
  map_dbl(~.x * 0.0328084, otherwise = NA_real_)
```

### Walk

The `walk` function makes list outputs more human readable. It calls the function (.f) for its 'side-effect' and returns the input (.x) removing all the unnecessary list bracketing.

In the example below we'll use the `population` dataset from the `tidyr` package to plot year vs. population for a selection of countries. 

```{r}
#select a random sample of countries
(countries <- unique(population$country) %>%
  sample(size = 5))

plots <- population %>%
  filter(country == countries) %>% # filter only countries of interest
  split(.$country) %>% # split the data by country
  map2(.x = .,
       .y = names(.),
       .f = ~ggplot(.x, aes(x = year, y = population)) +
         geom_line() +
         labs(title = .y))

walk(plots, print)
```

# Problem Solving

Now that we have some experience working with various functions in R, let's put our new found skills to the test by solving some problems. The `gh_users` dataset is also from the `repurrrsive` package and provides some data on github users.

First, let's take a look at the dataset.
```{r}
#summarize the dataset
summary(gh_users)

#determine whether the dataset is named
names(gh_users)
```

The `gh_users` daatset is comprised of 6 lists each comprised of 30 elements. We also know that the lists do not contain names. Let's take a look at the elements from the first list to see what kind of information is included.

```{r}
#exmaine the structure of the first list
str(gh_users[[1]])
```

Now, let's determine which of the users has the most public repositories.

```{r}
map_int(gh_users, ~.$public_repos) %>% #pull out the # of public repositories
  set_names(map_chr(gh_users, ~.$name)) %>% #assign names to each list element
  sort(decreasing = T) #sort the data
  
```

And there you have it. Jennifer Bryan has the most repositories with a whopping 168.

Now let's take a look at an intersting problem using the `sw_films` and `sw_people` data.

```{r}
# Turn data into correct dataframe format
film_by_character <- tibble(filmtitle = map_chr(sw_films, ~.$title)) %>%
    mutate(filmtitle, characters = map(sw_films, ~.$characters)) %>%
    unnest()

# Pull out elements from sw_people
sw_characters <- map_df(sw_people, `[`, c("height", "mass", "name", "url"))

# Join the two new objects
character_data <- inner_join(film_by_character, sw_characters, by = c("characters" = "url")) %>%
    # Make sure the columns are numbers
    mutate(height = as.numeric(height), mass = as.numeric(mass))

# Plot the heights, faceted by film title
ggplot(character_data, aes(x = height)) +
  geom_histogram(stat = "count") +
  facet_wrap(~ filmtitle)
```

