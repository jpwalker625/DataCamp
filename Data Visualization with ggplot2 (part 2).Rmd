---
title: "Data Visualization with ggplot2 (Part 2)"
author: "Joseph Walker"
date: "September 26, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#load required libraries
library(tidyverse)
library(MASS) #for datasets
```

# Part 2

In Part 1, we discussed 3 elements of the grammar of graphics: data, aesthetics, & geometries. We will continue our understnading of data viz by focusing our attention on other important layers: 

* Facets 
* Statistics 
* Coordinates 
* Themes 

## Statistics

Some statistics functions and geom functions can be used synonymously in ggplot2. An example of this is the `geom_bar`, `geom_histogram` and `geom_freqpoly` functions. Under the hood, these functions are using the `stat_bin` function to plot the data. 

```{r}
#assign plot object
p <- ggplot(iris, aes(x = Sepal.Width))

#plot with geom_histogram
p + geom_histogram()

#plot with geom_bar
p + geom_bar()

#plot with stat_bin
p + stat_bin()
```

Similarly, we can apply the smoothing statistics applied by the `stat_smooth` function with `geom_smooth`.

```{r}
#assign plot object
p <- ggplot(iris, aes(Petal.Length, Sepal.Length, color = factor(Species)))

#scatter plot with least squares modeling for each individual Species, and the dataset as a whole.
#we can determine whether the confidence interval ribbon appears by setting the 'se' argument.
p + geom_point() +
  geom_smooth(method = "lm") +
  geom_smooth(method = "lm", se = FALSE, aes(group = 1))
```

LOESS smoothing is a non-parametric form of regression that uses a weighted, sliding-window, average to calculate a line of best fit. We can control the size of this window with the span argument

 
```{r}
#set individual models to loess (default) and adjust the span
p + 
  geom_point() +
  geom_smooth(se = F, span = 0.7) 

#add overall model layer (loess) change individual model layers to 'lm'.
p + 
  geom_point()+
  geom_smooth(method = "lm") +
  stat_smooth(aes(group = 1), method = "loess", se = F, col = "black")
```

Notice in the plot above that I used both `geom_smooth` and `stat_smooth`. As mentioned before, these functions are interchangeable. 

Another nice feature of the smoothing functions is that you can extend the model to the full range of the plot by calling the logical (T or F) `fullrange ` argument. Notice how the further from the data you get, the se ribbon gets wider and wider.

```{r}
#apply fullrange of predictions for the individual Species linear regression models.
p + 
  geom_point()+
  geom_smooth(method = "lm", fullrange = T) +
  stat_smooth(aes(group = 1), method = "loess", se = F, col = "black")

```


In the plot above, the overall model is not included in the legend even though we applied the attribute `color = "black` to it. We can fix this by adding the color as an aesthetic, but we lose our control over the color.

```{r}
#add color as an aesthetic named 'All'
p + 
  geom_point()+
  geom_smooth(method = "lm") +
  stat_smooth(aes(group = 1, color = "All"), method = "loess", se = F)
```

Now the 'All' model appears in the legend but as I mentioned, we lost control over the color. We can fix this!

```{r}
# create a color vector with 4 colors, one for each color we will use in our plot
 
colors <- c("black", wesanderson::wes_palette(name = 'Darjeeling', 3))

#add manual color scale to change the colors.
p + 
  geom_point()+
  geom_smooth(method = "lm") +
  stat_smooth(aes(group = 1, color = "All"), method = "loess", se = F)+
  scale_color_manual("Species Colors", values = colors)


```

With `stat_quantile()`, we can apply quantile regression to a dataset. By default, the 1st, 2nd, and 3rd quantiles are modeled as a response to the predictor variable. Speciic quantiles can be specified with the quantiles argument. For example, to show only the median quantile, we can set `quantiles = 0.5`

```{r}
#examine the dataset
str(txhousing)

#create plot object sales vs. listings
p <- ggplot(txhousing, aes(x = listings, y = sales))

#scatterplot with quantile models
p + geom_point() + stat_quantile()

#group by year
p + 
  geom_point() +
  stat_quantile(aes(color = year))
```

Changing the color aesthetic did not produce the desired effect. That's because the `year` variable is an integer and we need it to be a factor.

```{r}
#make year a factor and adjust aesthetics/attributes
p +
  geom_point() +
  stat_quantile(aes(color = factor(year)), alpha = 0.6, size = 2)
```

While it's pretty, this plot is messy and not very readable. Let's clean it up by limiting which quantiles are plotted and adjusting our color scale to something more intuitive.

Even though we made year a factor, time is really a continuous variable and so we want to treat it as such when we choose our color scale. We can do this by making the `color = year` a continuous color scale, but keeping our quantile model grouped for each year separately with `group = factor(year)`.
```{r}
#creat plot object as before. Add color and group aesthetics
p <- ggplot(txhousing, aes(x = listings, y = sales, color = year, group = factor(year)))

#Plot point and quantile models for the median quantile. Modify the color scheme.
p + geom_point(color = "black", size = .75) +
  stat_quantile(alpha = 0.75, size = 2, quantiles = 0.5)+
  scale_color_gradientn(colours = pals::brewer.rdylbu(15))
```

The `stat_sum` function is useful for calculating the counts for each group in a dataset. 

```{r}
#create diamonds plot object clarity vs. cut
p <- ggplot(diamonds, aes(cut, clarity))

#make scatterplot
p + geom_point()

#reveal overplotting
p + geom_jitter(width = 0.3)

#apply stat_sum 
p + stat_sum()

#adjust scale_size
p + stat_sum() +
  scale_size(range = c(1,10))
```

##Stat Summary

Stat_summary can be used to perform summary statistics in conjunction with various ggplot2 and hmisc functions. You can even create custom functions to generate stats. 

The only caveat is that the variable names need to match the agrguments of the geometry being called.


## Coordinates & Facets

scales - set limits/breaks

coord_cartesian - zooms


```{r}
?zoo
```

As a rule of thumb, it is good practice to use a 1:1 aspect ratio when your axes show the same scales.

The following dataset uses the `crabs` dataset from the `MASS` package. CW refers to carpace width (mm) and RW refers to rear width (mm). The carpace is the upper section of the shell of the crab.

```{r}
#create plot object using the crabs dataset from the MASS package
p <- ggplot(crabs, aes(x = CW  ,y = RW, color = factor(sp), shape = factor(sex))) + 
  geom_point() + stat_smooth(method = "lm")+
  scale_shape_manual("sex", values = c(4, 10))

#plot with default aspect ratio
p

#plot with fixed 1:1 aspect ratio
p + coord_equal()
```

